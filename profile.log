FUNCTION  airline#extensions#ale#get_error()
Called 51 times
Total time:   0.007424
 Self time:   0.000412

count  total (s)   self (s)
   51   0.007404   0.000391   return airline#extensions#ale#get('error')

FUNCTION  airline#extensions#vista#currenttag()
Called 51 times
Total time:   0.000444
 Self time:   0.000444

count  total (s)   self (s)
   51              0.000184   if get(w:, 'airline_active', 0)
   51              0.000203     return get(b:, 'vista_nearest_method_or_function', '')
                              endif

FUNCTION  airline#extensions#neomake#get_errors()
Called 51 times
Total time:   0.002023
 Self time:   0.000577

count  total (s)   self (s)
   51   0.001742   0.000297   let counts = s:get_counts()
   51              0.000153   let errors = get(counts, 'E', 0)
   51              0.000088   return errors ? s:error_symbol.errors : ''

FUNCTION  airline#util#exec_funcrefs()
Called 6 times
Total time:   0.024256
 Self time:   0.000415

count  total (s)   self (s)
   34              0.000049     for Fn in a:list
   32   0.024092   0.000251       let code = call(Fn, a:000)
   32              0.000032       if code != 0
    4              0.000004         return code
                                  endif
   28              0.000017     endfor
    2              0.000001     return 0

FUNCTION  airline#statusline()
Called 51 times
Total time:   0.000709
 Self time:   0.000709

count  total (s)   self (s)
   51              0.000278   if has_key(s:contexts, a:winnr)
   51              0.000371     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>145_cursormoved_delayed_cb()
Called 5 times
Total time:   0.001542
 Self time:   0.000260

count  total (s)   self (s)
    5              0.000178     if getpos('.') == s:cursormoved_last_pos
    5   0.001347   0.000065         call neomake#CursorMoved()
    5              0.000004     endif

FUNCTION  airline#check_mode()
Called 51 times
Total time:   0.024108
 Self time:   0.008282

count  total (s)   self (s)
   51              0.000183   if !has_key(s:contexts, a:winnr)
                                return ''
                              endif
   51              0.000148   let context = s:contexts[a:winnr]
                            
   51              0.000174   if get(w:, 'airline_active', 1)
   51              0.000161     let l:m = mode(1)
   51              0.000104     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
                                  let l:mode = ['commandline']
                                elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
   51              0.000167       let l:mode = ['normal']
   51              0.000044     endif
   51              0.000310     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
                                endif
   51              0.000435     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
   51              0.000132       let l:m = l:m[0]
   51              0.000068     endif
   51              0.000336     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   51              0.000046   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
   51              0.000185   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
   51              0.000128   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
   51              0.000421   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
   51              0.000127   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
   51              0.000084   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
   51              0.000287   let mode_string = join(l:mode)
   51              0.000242   if get(w:, 'airline_lastmode', '') != mode_string
    1   0.000219   0.000012     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    1   0.015407   0.000026     call airline#highlighter#highlight(l:mode, context.bufnr)
    1   0.000248   0.000010     call airline#util#doautocmd('AirlineModeChanged')
    1              0.000026     let w:airline_lastmode = mode_string
    1              0.000002   endif
                            
   51              0.000059   return ''

FUNCTION  airline#util#append()
Called 357 times
Total time:   0.004523
 Self time:   0.004523

count  total (s)   self (s)
  357              0.001014   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
  357              0.001370   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  357              0.001275   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#themes#get_highlight()
Called 206 times
Total time:   0.032117
 Self time:   0.002112

count  total (s)   self (s)
  206   0.032037   0.002032   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  neomake#statusline#QflistCounts()
Called 102 times
Total time:   0.000452
 Self time:   0.000452

count  total (s)   self (s)
  102              0.000413     return get(s:counts, 'project', s:unknown_counts)

FUNCTION  airline#mode_changed()
Called 1 time
Total time:   0.000055
 Self time:   0.000044

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    1              0.000032   let g:airline#visual_active = (mode() =~? '[vs]')
    1   0.000021   0.000009   call airline#update_tabline()

FUNCTION  <SNR>122_new_airline_ale_get_line_number()
Called 102 times
Total time:   0.000486
 Self time:   0.000486

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
  102              0.000142   if a:cnt == 0
  102              0.000097     return ''
                              endif
                              let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
                              let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
                              if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
                              if empty(l:result)
                                  return ''
                              endif
                            
                              let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  airline#extensions#syntastic#get_error()
Called 51 times
Total time:   0.010950
 Self time:   0.000358

count  total (s)   self (s)
   51   0.010927   0.000335   return airline#extensions#syntastic#get('error')

FUNCTION  <SNR>118_CheckDefined()
Called 300 times
Total time:   0.015787
 Self time:   0.015787

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  300              0.003522   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  300              0.001159   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
  568              0.001201   for val in a:colors
  554              0.002112     if !empty(val) && val !=# 'NONE'
  286              0.000372       return a:colors
                                endif
  268              0.000197   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
   14              0.000030   let fg = g:airline#highlighter#normal_fg_hi
   14              0.000145   let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
   14              0.000020   if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
   14              0.000140   return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>156_BufferCacheExists()
Called 102 times
Total time:   0.000824
 Self time:   0.000824

count  total (s)   self (s)
  102              0.000647     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
  102              0.000101         return 0
                                endif
                            
                                return 1

FUNCTION  neomake#virtualtext#handle_current_error()
Called 5 times
Total time:   0.000537
 Self time:   0.000270

count  total (s)   self (s)
                                    " Clean always.
    5              0.000016         if !empty(s:cur_virtualtext)
                                        if bufexists(s:cur_virtualtext[0])
                                            call nvim_buf_clear_highlight(s:cur_virtualtext[0], s:cur_virtualtext[1], 0, -1)
                                        endif
                                    endif
    5              0.000020         if !get(g:, 'neomake_virtualtext_current_error', 1)
                                        return
                                    endif
    5   0.000303   0.000036         let entry = neomake#get_nearest_error()
    5              0.000012         if empty(entry)
    5              0.000014             let s:cur_virtualtext = []
    5              0.000005         else
                                        " Only add it when there is none already (stacking is not
                                        " supported).  https://github.com/neovim/neovim/issues/9285
                                        let buf_info = getbufvar(entry.bufnr, '_neomake_info', {})
                                        if index(get(buf_info, 'virtual_text_entries', []), entry.lnum) == -1
                                            let src_id = neomake#virtualtext#add_entry(entry, s:current_ns)
                                            let s:cur_virtualtext = [bufnr('%'), src_id]
                                        endif
                                    endif

FUNCTION  airline#extensions#neomake#get_warnings()
Called 51 times
Total time:   0.002527
 Self time:   0.000723

count  total (s)   self (s)
   51   0.002158   0.000354   let counts = s:get_counts()
   51              0.000206   let warnings = get(counts, 'W', 0)
   51              0.000114   return warnings ? s:warning_symbol.warnings : ''

FUNCTION  airline#extensions#default#apply()
Called 4 times
Total time:   0.004101
 Self time:   0.000227

count  total (s)   self (s)
    4              0.000010   let winnr = a:context.winnr
    4              0.000006   let active = a:context.active
                            
    4   0.000040   0.000025   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    4   0.001286   0.000041     call s:build_sections(a:builder, a:context, s:layout[0])
    4              0.000003   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
    4   0.000203   0.000041   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    4   0.000028   0.000016   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    4   0.002460   0.000021     call s:build_sections(a:builder, a:context, s:layout[1])
    4              0.000003   endif
                            
    4              0.000003   return 1

FUNCTION  airline#parts#filetype()
Called 51 times
Total time:   0.001104
 Self time:   0.000493

count  total (s)   self (s)
   51   0.001074   0.000462   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? 'â€¦' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 4 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    4              0.000017   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#parts#iminsert()
Called 51 times
Total time:   0.000396
 Self time:   0.000396

count  total (s)   self (s)
   51              0.000167   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   51              0.000047   return ''

FUNCTION  <SNR>114_invoke_funcrefs()
Called 4 times
Total time:   0.033547
 Self time:   0.000209

count  total (s)   self (s)
    4   0.000110   0.000019   let builder = airline#builder#new(a:context)
    4   0.005465   0.000051   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    4              0.000021   if err == 1
    4   0.027873   0.000039     let a:context.line = builder.build()
    4              0.000020     let s:contexts[a:context.winnr] = a:context
    4              0.000013     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    4              0.000035     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    4              0.000002   endif

FUNCTION  airline#extensions#term#apply()
Called 4 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    4              0.000018   if &buftype == 'terminal' || bufname('%')[0] == '!'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.s:section_a.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.s:termname())
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  <SNR>122_airline_ale_get_line_number()
Called 102 times
Total time:   0.001694
 Self time:   0.001208

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
  102              0.000423   if exists("*ale#statusline#FirstProblem")
  102   0.001120   0.000634     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  <SNR>41_on_cursor_moved()
Called 9 times
Total time:   0.000299
 Self time:   0.000215

count  total (s)   self (s)
    9              0.000092   if winnr() != s:active_winnr
                                call s:on_window_changed('CursorMoved')
                              endif
    9   0.000146   0.000062   call airline#update_tabline()

FUNCTION  airline#extensions#tabline#buflist#list()
Called 6 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    6              0.000034   if exists('s:current_buffer_list')
    6              0.000015     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  ale#ShouldDoNothing()
Called 9 times
Total time:   0.000335
 Self time:   0.000335

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
    9              0.000075     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
    9              0.000058     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
    9              0.000058     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
    9              0.000019     if l:filetype is# ''
    9              0.000011         return 1
                                endif
                            
                                " Do nothing for diff buffers.
                                if getbufvar(a:buffer, '&diff')
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
                                if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
                                if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
                                let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
                                if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
                                if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
                                if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
                                if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
                                if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
                                return 0

FUNCTION  ale#Var()
Called 9 times
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
    9              0.000045     let l:full_name = 'ale_' . a:variable_name
    9              0.000085     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
    9              0.000066     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  airline#util#winwidth()
Called 185 times
Total time:   0.002167
 Self time:   0.002167

count  total (s)   self (s)
  185              0.000692   let nr = get(a:000, 0, 0)
  185              0.000528   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
                              else
  185              0.000421     return winwidth(nr)
                              endif

FUNCTION  <SNR>118_GetHiCmd()
Called 23 times
Total time:   0.002180
 Self time:   0.002180

count  total (s)   self (s)
                              " a:list needs to have 5 items!
   23              0.000033   let res = ''
   23              0.000029   let i = -1
  138              0.000141   while i < 4
  115              0.000127     let i += 1
  115              0.000360     let item = get(a:list, i, '')
  115              0.000191     if item is ''
   77              0.000092       continue
                                endif
   38              0.000039     if i == 0
    3              0.000009       let res .= ' guifg='.item
    3              0.000003     elseif i == 1
    3              0.000007       let res .= ' guibg='.item
    3              0.000002     elseif i == 2
   23              0.000089       let res .= ' ctermfg='.item
   23              0.000028     elseif i == 3
    9              0.000021       let res .= ' ctermbg='.item
    9              0.000006     elseif i == 4
                                  let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
                                endif
   38              0.000026   endwhile
   23              0.000027   return res

FUNCTION  airline#util#doautocmd()
Called 3 times
Total time:   0.000595
 Self time:   0.000464

count  total (s)   self (s)
    3   0.000592   0.000461   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  44()
Called 102 times
Total time:   0.005099
 Self time:   0.005099

count  total (s)   self (s)
  102              0.001575     let newObj = copy(self)
                            
  102              0.000603     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
  102              0.000259     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
  102              0.000291     let newObj._rawLoclist = llist
  102              0.000218     let newObj._name = ''
  102              0.000313     let newObj._owner = bufnr('')
  102              0.000193     let newObj._sorted = 0
  102              0.000312     let newObj._columns = g:syntastic_cursor_columns
                            
  102              0.000142     return newObj

FUNCTION  45()
Called 102 times
Total time:   0.008756
 Self time:   0.002923

count  total (s)   self (s)
  102              0.000399     let buf = a:0 ? a:1 : bufnr('')
  102   0.001469   0.000736     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
  102              0.000527     if type(loclist) != type({}) || empty(loclist)
  102              0.000187         unlet! loclist
  102   0.005801   0.000702         let loclist = g:SyntasticLoclist.New([])
  102              0.000073     endif
  102              0.000109     return loclist

FUNCTION  airline#load_theme()
Called 2 times
Total time:   0.156671
 Self time:   0.000194

count  total (s)   self (s)
    2              0.000018   let g:airline_theme = get(g:, 'airline_theme', 'dark')
    2              0.000016   if exists('*airline#themes#{g:airline_theme}#refresh')
                                call airline#themes#{g:airline_theme}#refresh()
                              endif
                            
    2              0.000010   let palette = g:airline#themes#{g:airline_theme}#palette
    2   0.001973   0.000027   call airline#themes#patch(palette)
                            
    2              0.000009   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
    2   0.116603   0.000036   call airline#highlighter#load_theme()
    2   0.018897   0.000026   call airline#extensions#load_theme()
    2   0.019114   0.000021   call airline#update_statusline()

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 6 times
Total time:   0.000596
 Self time:   0.000159

count  total (s)   self (s)
    6   0.000083   0.000056   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
    6              0.000034   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
    6   0.000469   0.000059   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  neomake#statusline#LoclistCounts()
Called 102 times
Total time:   0.001316
 Self time:   0.001316

count  total (s)   self (s)
  102              0.000462     let buf = a:0 ? a:1 : bufnr('%')
  102              0.000159     if buf is# 'all'
                                    return s:counts
                                endif
  102              0.000382     return get(s:counts, buf, {})

FUNCTION  54()
Called 102 times
Total time:   0.008301
 Self time:   0.008301

count  total (s)   self (s)
  102              0.000346     if !exists('self._stl_format')
  102              0.000198         let self._stl_format = ''
  102              0.000069     endif
  102              0.000241     if !exists('self._stl_flag')
  102              0.000214         let self._stl_flag = ''
  102              0.000058     endif
                            
  102              0.000286     if g:syntastic_stl_format !=# self._stl_format
  102              0.000255         let self._stl_format = g:syntastic_stl_format
                            
  102              0.000225         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
  102              0.000178             let self._stl_flag = ''
  102              0.000066         endif
  102              0.000053     endif
                            
  102              0.000137     return self._stl_flag

FUNCTION  airline#extensions#tabline#tabs#map_keys()
Called 3 times
Total time:   0.008683
 Self time:   0.008683

count  total (s)   self (s)
    3              0.000145   if maparg('<Plug>AirlineSelectTab1', 'n') is# ':1tabn<CR>'
                                return
                              endif
    3              0.000025   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
    3              0.000004   if bidx_mode == 1
                                for i in range(1, 9)
                                  exe printf('noremap <silent> <Plug>AirlineSelectTab%d :%dtabn<CR>', i, i)
                                endfor
                              else
  270              0.000613       for i in range(11, 99)
  267              0.007267         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :%dtabn<CR>', i, i-10)
  267              0.000350       endfor
    3              0.000002     endif
    3              0.000043   noremap <silent> <Plug>AirlineSelectPrevTab gT
                              " tabn {count} goes to count tab does not go {count} tab pages forward!
    3              0.000064   noremap <silent> <Plug>AirlineSelectNextTab :<C-U>exe repeat(':tabn\|', v:count1)<cr>

FUNCTION  airline#extensions#ctrlp#load_theme()
Called 2 times
Total time:   0.008165
 Self time:   0.000979

count  total (s)   self (s)
    2              0.000007   if exists('a:palette.ctrlp')
    2              0.000004     let theme = a:palette.ctrlp
    2              0.000001   else
                                let s:color_template = has_key(a:palette, s:color_template) ? s:color_template : 'insert'
                                let theme = airline#extensions#ctrlp#generate_color_map( a:palette[s:color_template]['airline_c'], a:palette[s:color_template]['airline_b'], a:palette[s:color_template]['airline_a'])
                              endif
   20              0.000052   for key in keys(theme)
   18   0.007703   0.000518     call airline#highlighter#exec(key, theme[key])
   18              0.000357   endfor

FUNCTION  <SNR>118_group_not_done()
Called 150 times
Total time:   0.001933
 Self time:   0.001933

count  total (s)   self (s)
  150              0.000933   if index(a:list, a:name) == -1
  150              0.000658     call add(a:list, a:name)
  150              0.000171     return 1
                              else
                                if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
                                return 0
                              endif

FUNCTION  airline#extensions#ale#get()
Called 102 times
Total time:   0.015540
 Self time:   0.008219

count  total (s)   self (s)
  102              0.000403   if !exists(':ALELint')
                                return ''
                              endif
                            
  102              0.000502   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
  102              0.000473   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
  102              0.000439   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
  102              0.000428   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
  102              0.000281   let is_err = a:type ==# 'error'
                            
  102   0.002050   0.000719   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
                                return is_err ? '' : checking_symbol
                              endif
                            
  102              0.000259   let symbol = is_err ? error_symbol : warning_symbol
                            
  102   0.004644   0.000615   let counts = ale#statusline#Count(bufnr(''))
  102              0.000581   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
  102              0.000287     let errors = counts.error + counts.style_error
  102              0.000285     let num = is_err ? errors : counts.total - errors
  102              0.000076   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
  102              0.000194   if show_line_numbers == 1
  102   0.003195   0.001235     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  ale#engine#IsCheckingBuffer()
Called 102 times
Total time:   0.001332
 Self time:   0.001332

count  total (s)   self (s)
  102              0.000469     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
  102              0.000734     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  <SNR>133_section_is_empty()
Called 36 times
Total time:   0.000485
 Self time:   0.000485

count  total (s)   self (s)
   36              0.000064   let start=1
                            
                              " do not check for inactive windows or the tabline
   36              0.000049   if a:self._context.active == 0
                                return 0
                              elseif get(a:self._context, 'tabline', 0)
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
   36              0.000105   if get(g:, 'airline_skip_empty_sections', 0) == 0
   36              0.000025     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#util#wrap()
Called 561 times
Total time:   0.003497
 Self time:   0.003497

count  total (s)   self (s)
  561              0.001670   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
  561              0.000646   return a:text

FUNCTION  382()
Called 4 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    4              0.000015   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  384()
Called 32 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
   32              0.000116   call add(self._sections, [a:group, a:contents])

FUNCTION  389()
Called 4 times
Total time:   0.027833
 Self time:   0.003224

count  total (s)   self (s)
    4              0.000006   let side = 1
    4              0.000013   let line = ''
    4              0.000004   let i = 0
    4              0.000010   let length = len(self._sections)
    4              0.000005   let split = 0
    4              0.000005   let is_empty = 0
    4              0.000005   let prev_group = ''
                            
   40              0.000061   while i < length
   36              0.000085     let section = self._sections[i]
   36              0.000062     let group = section[0]
   36              0.000068     let contents = section[1]
   36              0.000049     let pgroup = prev_group
   36   0.000679   0.000267     let prev_group = airline#builder#get_prev_group(self._sections, i)
   36              0.000153     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
   36              0.000029     if is_empty
                                  let prev_group = pgroup
                                endif
   36   0.000700   0.000215     let is_empty = s:section_is_empty(self, contents)
                            
   36              0.000025     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   36              0.000045     if group == ''
                                  let line .= contents
                                elseif group == '|'
    4              0.000004       let side = 0
    4              0.000009       let line .= contents
    4              0.000003       let split = 1
    4              0.000002     else
   32              0.000038       if prev_group == ''
    4              0.000014         let line .= '%#'.group.'#'
    4              0.000003       elseif split
    4              0.000003         if !is_empty
    4   0.002240   0.000024           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    4              0.000002         endif
    4              0.000004         let split = 0
    4              0.000002       else
   24              0.000019         if !is_empty
   24   0.019992   0.000150           let line .= s:get_seperator(self, prev_group, group, side)
   24              0.000014         endif
   24              0.000011       endif
   32   0.002109   0.000454       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   32              0.000019     endif
                            
   36              0.000048     let i = i + 1
   36              0.000025   endwhile
                            
    4              0.000004   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
    4              0.000004   return line

FUNCTION  airline#extensions#tabline#get()
Called 3 times
Total time:   0.009129
 Self time:   0.000258

count  total (s)   self (s)
    3              0.000034   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    3              0.000021   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
    3              0.000020   let curtabcnt = tabpagenr('$')
    3              0.000007   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                                call airline#extensions#tabline#tabws#invalidate()
                              endif
                            
    3              0.000017   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
    3              0.000002   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif s:tabws
                                return airline#extensions#tabline#tabws#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
                                return airline#extensions#tabline#buffers#get()
                              else
    3   0.008914   0.000043     return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  <SNR>133_get_transitioned_seperator()
Called 28 times
Total time:   0.015432
 Self time:   0.000823

count  total (s)   self (s)
   28              0.000033   let line = ''
   28              0.000104   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
   28   0.014769   0.000161     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   28              0.000120     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   28              0.000103     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   28              0.000068     let line .= '%#'.a:group.'#'
   28              0.000013   endif
   28              0.000025   return line

FUNCTION  airline#util#getwinvar()
Called 60 times
Total time:   0.000221
 Self time:   0.000221

count  total (s)   self (s)
   60              0.000199     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#whitespace#check()
Called 51 times
Total time:   0.009536
 Self time:   0.007630

count  total (s)   self (s)
   51              0.000246   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   51              0.000408   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
   51              0.000507   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   51              0.000213   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
                              endif
   51   0.002223   0.000317   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  ale#statusline#Count()
Called 102 times
Total time:   0.004029
 Self time:   0.001242

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
  102   0.003903   0.001116     return copy(s:GetCounts(a:buffer))

FUNCTION  airline#extensions#tabline#title()
Called 3 times
Total time:   0.000623
 Self time:   0.000260

count  total (s)   self (s)
    3              0.000006   let title = ''
    3              0.000003   if s:taboo
                                let title = TabooTabTitle(a:n)
                              endif
                            
    3              0.000037   if empty(title) && exists('*gettabvar')
    3              0.000019     let title = gettabvar(a:n, 'title')
    3              0.000002   endif
                            
    3              0.000011   if empty(title)
    3              0.000017     let buflist = tabpagebuflist(a:n)
    3              0.000007     let winnr = tabpagewinnr(a:n)
    3   0.000074   0.000036     let all_buffers = airline#extensions#tabline#buflist#list()
    3   0.000399   0.000075     return airline#extensions#tabline#get_buffer_name( buflist[winnr - 1], filter(buflist, 'index(all_buffers, v:val) != -1'))
                              endif
                            
                              return title

FUNCTION  syntastic#util#getbufvar()
Called 102 times
Total time:   0.000734
 Self time:   0.000734

count  total (s)   self (s)
  102              0.000652     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  airline#update_statusline()
Called 4 times
Total time:   0.033905
 Self time:   0.000238

count  total (s)   self (s)
    4   0.000038   0.000024   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    4              0.000027   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    4   0.000125   0.000019   call airline#update_statusline_inactive(range)
                            
    4              0.000007   unlet! w:airline_render_left w:airline_render_right
    4              0.000049   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    4              0.000005   let w:airline_active = 1
    4              0.000021   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    4   0.033613   0.000066   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  airline#extensions#syntastic#get()
Called 102 times
Total time:   0.022867
 Self time:   0.003670

count  total (s)   self (s)
  102              0.000484   let _backup = get(g:, 'syntastic_stl_format', '')
  102              0.000330   let is_err = (a:type  is# 'error')
  102              0.000125   if is_err
   51              0.000227     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_err', '%E{[%fe(#%e)]}')
   51              0.000036   else
   51              0.000276     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_warn', '%W{[%fw(#%w)]}')
   51              0.000040   endif
  102   0.019750   0.000553   let cnt = SyntasticStatuslineFlag()
  102              0.000269   if !empty(_backup)
  102              0.000226     let g:syntastic_stl_format = _backup
  102              0.000066   endif
  102              0.000243   if empty(cnt)
  102              0.000098     return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  airline#themes#patch()
Called 2 times
Total time:   0.001946
 Self time:   0.001946

count  total (s)   self (s)
   30              0.000115   for mode in keys(a:palette)
   28              0.000061     if mode == 'accents'
    2              0.000004       continue
                                endif
   26              0.000115     if !has_key(a:palette[mode], 'airline_warning')
                                  let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
                                endif
   26              0.000772     if !has_key(a:palette[mode], 'airline_error')
                                  let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
                                endif
   26              0.000143     if !has_key(a:palette[mode], 'airline_term')
                                  let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
                                endif
   26              0.000079   endfor
                            
    2              0.000016   let a:palette.accents = get(a:palette, 'accents', {})
    2              0.000099   let a:palette.accents.none = [ '', '', '', '', '' ]
    2              0.000017   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    2              0.000055   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    2              0.000009   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
    2              0.000006   if !has_key(a:palette.accents, 'green')
                                let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
                              endif
    2              0.000006   if !has_key(a:palette.accents, 'blue')
                                let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
                              endif
    2              0.000006   if !has_key(a:palette.accents, 'yellow')
                                let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
                              endif
    2              0.000006   if !has_key(a:palette.accents, 'orange')
                                let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
                              endif
    2              0.000005   if !has_key(a:palette.accents, 'purple')
                                let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
                              endif

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 1 time
Total time:   0.000207
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000003   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
    1              0.000008     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    1              0.000000   endif
                            
    1              0.000001   if !empty(colors)
    1   0.000189   0.000007     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    1              0.000000   endif

FUNCTION  airline#highlighter#load_theme()
Called 2 times
Total time:   0.116567
 Self time:   0.000214

count  total (s)   self (s)
    2              0.000006   if pumvisible()
                                return
                              endif
    2              0.000027   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
                              endfor
    2   0.062900   0.000071   call airline#highlighter#highlight(['inactive'])
    2              0.000018   if getbufvar( bufnr('%'), '&modified'  )
                                call airline#highlighter#highlight(['normal', 'modified'])
                              else
    2   0.053584   0.000060     call airline#highlighter#highlight(['normal'])
    2              0.000002   endif

FUNCTION  airline#update_statusline_inactive()
Called 4 times
Total time:   0.000107
 Self time:   0.000096

count  total (s)   self (s)
    4   0.000026   0.000015   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    4              0.000006   for nr in a:range
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor

FUNCTION  <SNR>133_get_accented_line()
Called 32 times
Total time:   0.001655
 Self time:   0.001655

count  total (s)   self (s)
   32              0.000038   if a:self._context.active
                                " active window
   32              0.000041     let contents = []
   32              0.000216     let content_parts = split(a:contents, '__accent')
   76              0.000108     for cpart in content_parts
   44              0.000307       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   44              0.000107       call add(contents, cpart)
   44              0.000030     endfor
   32              0.000132     let line = join(contents, a:group)
   32              0.000226     let line = substitute(line, '__restore__', a:group, 'g')
   32              0.000018   else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
   32              0.000044   return line

FUNCTION  airline#update_statusline_focuslost()
Called 2 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    2              0.000023   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
                              endif

FUNCTION  airline#highlighter#highlight()
Called 5 times
Total time:   0.131735
 Self time:   0.019473

count  total (s)   self (s)
    5              0.000017   let bufnr = a:0 ? a:1 : ''
    5              0.000024   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    5              0.000050   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    5              0.000017   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    5              0.000010   let airline_grouplist = []
    5              0.000024   let buffers_in_tabpage = sort(tabpagebuflist())
    5              0.000016   if exists("*uniq")
    5              0.000016     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    5              0.000004   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   10              0.000025   for mode in reverse(mapped)
    5              0.000036     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    5              0.000022       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  125              0.000546       for kvp in items(dict)
  120              0.000289         let mode_colors = kvp[1]
  120              0.000236         let name = kvp[0]
  120              0.001150         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  120              0.001415         if name =~# 'airline_c\d\+'
    5              0.000049           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
    5              0.000019           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
    5              0.000013         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   70              0.000088           continue
                                    endif
   50   0.001401   0.000734         if s:group_not_done(airline_grouplist, name.suffix)
   50   0.020081   0.000540           call airline#highlighter#exec(name.suffix, mode_colors)
   50              0.000049         endif
                            
  150              0.000473         for accent in keys(s:accents)
  100              0.000464           if !has_key(p.accents, accent)
                                        continue
                                      endif
  100              0.000910           let colors = copy(mode_colors)
  100              0.000458           if p.accents[accent][0] != ''
   50              0.000160             let colors[0] = p.accents[accent][0]
   50              0.000035           endif
  100              0.000277           if p.accents[accent][2] != ''
   50              0.000119             let colors[2] = p.accents[accent][2]
   50              0.000038           endif
  100              0.000246           if len(colors) >= 5
  100              0.000490             let colors[4] = get(p.accents[accent], 4, '')
  100              0.000074           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  100   0.002218   0.000951           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  100   0.040735   0.001238             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  100              0.000098           endif
  100              0.000123         endfor
   50              0.000039       endfor
                            
    5              0.000013       if empty(s:separators)
                                    " nothing to be done
                                    continue
                                  endif
                                  " TODO: optimize this
   80              0.000293       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
   75   0.052036   0.000745         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   75              0.000179       endfor
    5              0.000004     endif
    5              0.000010   endfor

FUNCTION  airline#parts#ffenc()
Called 51 times
Total time:   0.001595
 Self time:   0.001595

count  total (s)   self (s)
   51              0.000233   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   51              0.000129   let bomb     = &l:bomb ? '[BOM]' : ''
   51              0.000518   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   51              0.000320   if expected is# &fenc.bomb.ff
                                return ''
                              else
   51              0.000237     return &fenc.bomb.ff
                              endif

FUNCTION  airline#util#ignore_buf()
Called 51 times
Total time:   0.001892
 Self time:   0.001892

count  total (s)   self (s)
   51              0.000470   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
   51              0.001366   return match(a:name, pat) > -1

FUNCTION  neomake#CursorMovedDelayed()
Called 9 times
Total time:   0.000286
 Self time:   0.000286

count  total (s)   self (s)
    9              0.000040     if exists('s:cursormoved_timer')
    9              0.000028         call timer_stop(s:cursormoved_timer)
    9              0.000017     endif
    9              0.000041     let delay = get(g:, 'neomake_cursormoved_delay', 100)
    9              0.000090     let s:cursormoved_timer = timer_start(delay, function('s:cursormoved_delayed_cb'))
    9              0.000051     let s:cursormoved_last_pos = getpos('.')

FUNCTION  airline#builder#get_prev_group()
Called 36 times
Total time:   0.000412
 Self time:   0.000412

count  total (s)   self (s)
   36              0.000058   let x = a:i - 1
   40              0.000045   while x >= 0
   36              0.000072     let group = a:sections[x][0]
   36              0.000076     if group != '' && group != '|'
   32              0.000048       return group
                                endif
    4              0.000004     let x = x - 1
    4              0.000004   endwhile
    4              0.000004   return ''

FUNCTION  airline#extensions#tabline#tabs#get()
Called 3 times
Total time:   0.008871
 Self time:   0.000188

count  total (s)   self (s)
    3              0.000026   let curbuf = bufnr('%')
    3              0.000014   let curtab = tabpagenr()
    3              0.000012   try
    3   0.008724   0.000041     call airline#extensions#tabline#tabs#map_keys()
    3              0.000003   catch
                                " no-op
                              endtry
    3              0.000030   if curbuf == s:current_bufnr && curtab == s:current_tabnr && &columns == s:column_width
    3              0.000028     if !g:airline_detect_modified || getbufvar(curbuf, '&modified') == s:current_modified
    3              0.000012       return s:current_tabline
                                endif
                              endif
                            
                              let b = airline#extensions#tabline#new_builder()
                            
                              call airline#extensions#tabline#add_label(b, 'tabs', 0)
                            
                              function! b.get_group(i) dict
                                let curtab = tabpagenr()
                                let group = 'airline_tab'
                                if a:i == curtab
                                  let group = 'airline_tabsel'
                                  if g:airline_detect_modified
                                    for bi in tabpagebuflist(curtab)
                                      if getbufvar(bi, '&modified')
                                        let group = 'airline_tabmod'
                                      endif
                                    endfor
                                  endif
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
                              function! b.get_title(i) dict
                                let val = '%('
                            
                                if get(g:, 'airline#extensions#tabline#show_tab_nr', 1)
                                  let tab_nr_type = get(g:, 'airline#extensions#tabline#tab_nr_type', 0)
                                  let val .= airline#extensions#tabline#tabs#tabnr_formatter(tab_nr_type, a:i)
                                endif
                            
                                return val.'%'.a:i.'T %{airline#extensions#tabline#title('.a:i.')} %)'
                              endfunction
                            
                              call b.insert_titles(curtab, 1, tabpagenr('$'))
                            
                              call b.add_section('airline_tabfill', '')
                              call b.split()
                              call b.add_section('airline_tabfill', '')
                            
                              if get(g:, 'airline#extensions#tabline#show_close_button', 1)
                                call b.add_section('airline_tab_right', ' %999X'. get(g:, 'airline#extensions#tabline#close_symbol', 'X').' ')
                              endif
                            
                              if get(g:, 'airline#extensions#tabline#show_splits', 1) == 1
                                let buffers = tabpagebuflist(curtab)
                                for nr in buffers
                                  let group = airline#extensions#tabline#group_of_bufnr(buffers, nr) . "_right"
                                  call b.add_section_spaced(group, '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)')
                                endfor
                                if get(g:, 'airline#extensions#tabline#show_buffers', 1)
                                  call airline#extensions#tabline#add_label(b, 'buffers', 1)
                                endif
                              endif
                              call airline#extensions#tabline#add_tab_label(b)
                            
                              let s:current_bufnr = curbuf
                              let s:current_tabnr = curtab
                              let s:column_width = &columns
                              let s:current_tabline = b.build()
                              return s:current_tabline

FUNCTION  airline#update_tabline()
Called 12 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
   12              0.000051   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
                              endif

FUNCTION  airline#parts#paste()
Called 51 times
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
   51              0.000148   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#parts#readonly()
Called 51 times
Total time:   0.003040
 Self time:   0.001148

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   51   0.002470   0.000578   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
   51              0.000169   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
   51              0.000094     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  airline#highlighter#exec()
Called 300 times
Total time:   0.105589
 Self time:   0.028198

count  total (s)   self (s)
  300              0.000627   if pumvisible()
                                return
                              endif
  300              0.000557   let colors = a:colors
  300              0.000946   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  300   0.059022   0.005774   let old_hi = airline#highlighter#get_highlight(a:group)
  300              0.000870   if len(colors) == 4
  103              0.000279     call add(colors, '')
  103              0.000055   endif
  300              0.000509   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  300              0.002711     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  300              0.000273   endif
  300   0.017957   0.002170   let colors = s:CheckDefined(colors)
  300   0.008692   0.002515   if old_hi != new_hi || !s:hl_group_exists(a:group)
   23   0.002383   0.000203     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   23              0.000171     exe cmd
   23              0.000077     if has_key(s:hl_groups, a:group)
   23              0.000061       let s:hl_groups[a:group] = colors
   23              0.000014     endif
   23              0.000011   endif

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 6 times
Total time:   0.000411
 Self time:   0.000244

count  total (s)   self (s)
    6              0.000021   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
    6              0.000007   let _ = ''
                            
    6              0.000015   let name = bufname(a:bufnr)
    6              0.000011   if empty(name)
                                let _ .= '[No Name]'
                              else
    6              0.000006     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Ð£Ñ‡Ñ‘Ð±Ð°/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
    6              0.000031       let _ .= pathshorten(fnamemodify(name, fmod))
    6              0.000004     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
    6              0.000022     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
    6              0.000003   endif
                            
    6   0.000229   0.000062   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  neomake#GetCurrentErrorMsg()
Called 5 times
Total time:   0.000445
 Self time:   0.000080

count  total (s)   self (s)
    5   0.000420   0.000055     let entry = neomake#get_nearest_error()
    5              0.000013     if empty(entry)
    5              0.000006         return ''
                                endif
                                let r = entry.maker_name . ': ' . entry.text
                                let suffix = entry.type . (entry.nr != -1 ? entry.nr : '')
                                if !empty(suffix)
                                    let r .= ' ('.suffix.')'
                                endif
                                return r

FUNCTION  neomake#get_nearest_error()
Called 10 times
Total time:   0.000631
 Self time:   0.000631

count  total (s)   self (s)
   10              0.000045     let buf = bufnr('%')
   10              0.000033     let ln = line('.')
   10              0.000022     let ln_errors = []
                            
   30              0.000089     for maker_type in ['file', 'project']
   20              0.000136         let buf_errors = get(s:current_errors[maker_type], buf, {})
   20              0.000095         let ln_errors += get(buf_errors, ln, [])
   20              0.000035     endfor
                            
   10              0.000027     if empty(ln_errors)
   10              0.000016         return {}
                                endif
                            
                                if len(ln_errors) > 1
                                    call sort(ln_errors, function('neomake#utils#sort_by_col'))
                                endif
                                return ln_errors[0]

FUNCTION  neomake#CursorMoved()
Called 5 times
Total time:   0.001282
 Self time:   0.000092

count  total (s)   self (s)
    5   0.000697   0.000044     call neomake#EchoCurrentError()
    5   0.000579   0.000042     call neomake#virtualtext#handle_current_error()

FUNCTION  airline#builder#should_change_group()
Called 24 times
Total time:   0.006332
 Self time:   0.000502

count  total (s)   self (s)
   24              0.000042   if a:group1 == a:group2
                                return 0
                              endif
   24   0.003109   0.000134   let color1 = airline#highlighter#get_highlight(a:group1)
   24   0.002976   0.000122   let color2 = airline#highlighter#get_highlight(a:group2)
   24              0.000033   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   24              0.000059     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>134_get_section()
Called 44 times
Total time:   0.002238
 Self time:   0.001768

count  total (s)   self (s)
   44              0.000120   if has_key(s:section_truncate_width, a:key)
   32   0.000474   0.000172     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
   32              0.000017   endif
   44              0.000086   let spc = g:airline_symbols.space
   44              0.000197   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
   44   0.000522   0.000353   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   44              0.000421   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   44              0.000176   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 6 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
    6              0.000031   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
    6              0.000068   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
    6              0.000026   if getbufvar(a:bufnr, '&modified') == 1
                                let _ .= s:buf_modified_symbol
                              endif
    6              0.000012   return _

FUNCTION  airline#parts#spell()
Called 51 times
Total time:   0.001673
 Self time:   0.001673

count  total (s)   self (s)
   51              0.000744   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   51              0.000115   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
   51              0.000048   return ''

FUNCTION  <SNR>118_get_syn()
Called 1108 times
Total time:   0.042562
 Self time:   0.042562

count  total (s)   self (s)
 1108              0.003506   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 1108              0.002111   let color = ''
 1108              0.003797   if hlexists(a:group)
 1046              0.009035     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1046              0.000760   endif
 1108              0.003634   if empty(color) || color == -1
                                " should always exists
   88              0.001022     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   88              0.000237     if empty(color) || color == -1
   57              0.000072       let color = 'NONE'
   57              0.000037     endif
   88              0.000045   endif
 1108              0.001228   return color

FUNCTION  <SNR>122_airline_ale_count()
Called 102 times
Total time:   0.000266
 Self time:   0.000266

count  total (s)   self (s)
  102              0.000215   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  airline#parts#crypt()
Called 51 times
Total time:   0.000534
 Self time:   0.000534

count  total (s)   self (s)
   51              0.000493   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#keymap#status()
Called 51 times
Total time:   0.000719
 Self time:   0.000719

count  total (s)   self (s)
   51              0.000334   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   51              0.000338     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  airline#extensions#load_theme()
Called 2 times
Total time:   0.018871
 Self time:   0.000030

count  total (s)   self (s)
    2   0.018870   0.000028   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  <SNR>162_StopCursorTimer()
Called 9 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    9              0.000017     if s:cursor_timer != -1
    8              0.000029         call timer_stop(s:cursor_timer)
    8              0.000022         let s:cursor_timer = -1
    8              0.000006     endif

FUNCTION  airline#parts#mode()
Called 51 times
Total time:   0.002383
 Self time:   0.000560

count  total (s)   self (s)
   51   0.002349   0.000525   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#quickfix#apply()
Called 4 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    4              0.000012   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  airline#highlighter#add_separator()
Called 28 times
Total time:   0.014609
 Self time:   0.000380

count  total (s)   self (s)
   28              0.000158   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   28   0.014438   0.000209   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>156_CreateCountDict()
Called 102 times
Total time:   0.000920
 Self time:   0.000920

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
  102              0.000737     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  airline#extensions#wordcount#apply()
Called 4 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    4              0.000030   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'org', 'rst', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    4              0.000008   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    4              0.000006   if did_filetype()
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
                              endif
                            
    4              0.000009   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
                              endif

FUNCTION  <SNR>118_get_array()
Called 554 times
Total time:   0.007306
 Self time:   0.007306

count  total (s)   self (s)
  554              0.003415   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  554              0.003530   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  <SNR>118_exec_separator()
Called 103 times
Total time:   0.065519
 Self time:   0.004377

count  total (s)   self (s)
  103              0.000190   if pumvisible()
                                return
                              endif
  103              0.000390   let group = a:from.'_to_'.a:to.a:suffix
  103   0.017581   0.000704   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  103   0.015842   0.000602   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  103              0.000131   if a:inverse
   33              0.000156     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   33              0.000021   else
   70              0.000306     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   70              0.000046   endif
  103              0.000458   let a:dict[group] = colors
  103   0.029798   0.000772   call airline#highlighter#exec(group, colors)

FUNCTION  neomake#EchoCurrentError()
Called 5 times
Total time:   0.000653
 Self time:   0.000208

count  total (s)   self (s)
    5              0.000035     if !get(g:, 'neomake_echo_current_error', 1)
                                    return
                                endif
                                " a:1 might be a timer from the VimResized event.
    5              0.000027     let force = a:0 ? a:1 : 0
                            
    5   0.000490   0.000045     let message = neomake#GetCurrentErrorMsg()
    5              0.000014     if empty(message)
    5              0.000021         if exists('s:neomake_last_echoed_error')
                                        echon ''
                                        unlet s:neomake_last_echoed_error
                                    endif
    5              0.000005         return
                                endif
                                if !force && exists('s:neomake_last_echoed_error') && s:neomake_last_echoed_error == message
                                    return
                                endif
                                let s:neomake_last_echoed_error = message
                                call neomake#utils#WideMessage(message)

FUNCTION  <SNR>134_build_sections()
Called 8 times
Total time:   0.003684
 Self time:   0.000464

count  total (s)   self (s)
   40              0.000052   for key in a:keys
   32              0.000095     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
   32   0.003388   0.000168     call s:add_section(a:builder, a:context, key)
   32              0.000034   endfor

FUNCTION  airline#extensions#tabline#load_theme()
Called 2 times
Total time:   0.010567
 Self time:   0.000408

count  total (s)   self (s)
    2              0.000004   if pumvisible()
                                return
                              endif
    2              0.000010   let colors    = get(a:palette, 'tabline', {})
    2              0.000009   let tablabel  = get(colors, 'airline_tablabel', a:palette.normal.airline_b)
                              " Theme for tabs on the left
    2              0.000007   let tab     = get(colors, 'airline_tab', a:palette.normal.airline_b)
    2              0.000007   let tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
    2              0.000007   let tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
    2              0.000007   let tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
    2              0.000007   let tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
    2              0.000006   let tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
    2              0.000010   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
    2              0.000007     let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
    2              0.000001   else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
                              endif
    2   0.000513   0.000016   call airline#highlighter#exec('airline_tablabel', tablabel)
    2   0.001923   0.000017   call airline#highlighter#exec('airline_tab', tab)
    2   0.000513   0.000016   call airline#highlighter#exec('airline_tabsel', tabsel)
    2   0.000838   0.000015   call airline#highlighter#exec('airline_tabtype', tabtype)
    2   0.000492   0.000016   call airline#highlighter#exec('airline_tabfill', tabfill)
    2   0.000879   0.000015   call airline#highlighter#exec('airline_tabmod', tabmod)
    2   0.000479   0.000015   call airline#highlighter#exec('airline_tabmod_unsel', tabmodu)
    2   0.001571   0.000016   call airline#highlighter#exec('airline_tabhid', tabhid)
                            
                              " Theme for tabs on the right
                              " label on the right
    2              0.000011   let tablabel_r  = get(colors, 'airline_tablabel', a:palette.normal.airline_b)
    2              0.000008   let tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
    2              0.000008   let tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
    2              0.000008   let tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
    2              0.000007   let tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
    2              0.000010   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
    2              0.000010     let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
    2              0.000001   else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
                              endif
    2   0.000489   0.000016   call airline#highlighter#exec('airline_tablabel_right', tablabel_r)
    2   0.000482   0.000017   call airline#highlighter#exec('airline_tab_right',    tab_right)
    2   0.000478   0.000015   call airline#highlighter#exec('airline_tabsel_right', tabsel_right)
    2   0.000656   0.000015   call airline#highlighter#exec('airline_tabmod_right', tabmod_right)
    2   0.000542   0.000021   call airline#highlighter#exec('airline_tabhid_right', tabhid_right)
    2   0.000528   0.000014   call airline#highlighter#exec('airline_tabmod_unsel_right', tabmodu_right)

FUNCTION  airline#extensions#apply()
Called 4 times
Total time:   0.000658
 Self time:   0.000360

count  total (s)   self (s)
    4              0.000016   let filetype_overrides = get(s:, 'filetype_overrides', {})
    4              0.000019   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    4   0.000330   0.000033   if s:is_excluded_window()
                                return -1
                              endif
                            
    4              0.000046   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                              endif
                            
    4              0.000005   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
    4              0.000029   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
    4              0.000006   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    4              0.000016   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  <SNR>134_add_section()
Called 32 times
Total time:   0.003220
 Self time:   0.001001

count  total (s)   self (s)
   32              0.000148     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   32   0.000743   0.000226     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
   32              0.000027     if condition
                                  call a:builder.add_raw('%(')
                                endif
   32   0.002007   0.000304     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   32              0.000029     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  ale#cursor#EchoCursorWarning()
Called 9 times
Total time:   0.000742
 Self time:   0.000407

count  total (s)   self (s)
    9              0.000126     let l:buffer = bufnr('')
                            
    9              0.000033     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    9              0.000039     if mode(1) isnot# 'n'
                                    return
                                endif
                            
    9   0.000440   0.000105     if ale#ShouldDoNothing(l:buffer)
    9              0.000009         return
                                endif
                            
                                let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
                                if g:ale_echo_cursor
                                    if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
                                    elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
                                    endif
                                endif
                            
                                if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif

FUNCTION  airline#highlighter#get_highlight()
Called 554 times
Total time:   0.089083
 Self time:   0.039215

count  total (s)   self (s)
  554              0.010414   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  554              0.002490   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
                              else
  554   0.026258   0.004015     let fg = s:get_syn(a:group, 'fg')
  554   0.023700   0.003381     let bg = s:get_syn(a:group, 'bg')
  554              0.004010     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  554              0.000582     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
                                else
  554   0.011223   0.003917       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
  554              0.000411     endif
  554              0.000263   endif
  554              0.002281   let s:hl_groups[a:group] = res
  554              0.000525   return res

FUNCTION  airline#util#shorten()
Called 102 times
Total time:   0.003730
 Self time:   0.002476

count  total (s)   self (s)
  102   0.002444   0.001190   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return 'â€¦'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'â€¦'
                                endif
                              else
  102              0.000125     return a:text
                              endif

FUNCTION  <SNR>98_Highlight_Matching_Pair()
Called 9 times
Total time:   0.001096
 Self time:   0.001096

count  total (s)   self (s)
                              " Remove any previous match.
    9              0.000039   if exists('w:paren_hl_on') && w:paren_hl_on
    1              0.000004     silent! call matchdelete(3)
    1              0.000002     let w:paren_hl_on = 0
    1              0.000001   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    9              0.000063   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    9              0.000025   let c_lnum = line('.')
    9              0.000030   let c_col = col('.')
    9              0.000019   let before = 0
                            
    9              0.000042   let text = getline(c_lnum)
    9              0.000151   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    9              0.000036   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
    9              0.000060     let [c_before, c] = matches[1:2]
    9              0.000006   endif
    9              0.000223   let plist = split(&matchpairs, '.\zs[:,]')
    9              0.000046   let i = index(plist, c)
    9              0.000011   if i < 0
                                " not found, in Insert mode try character before the cursor
    9              0.000046     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
    9              0.000014     if i < 0
                                  " not found, nothing to do
    9              0.000008       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>156_GetCounts()
Called 102 times
Total time:   0.002787
 Self time:   0.001043

count  total (s)   self (s)
  102   0.001327   0.000503     if !s:BufferCacheExists(a:buffer)
  102   0.001370   0.000450         return s:CreateCountDict()
                                endif
                            
                                call s:UpdateCacheIfNecessary(a:buffer)
                            
                                return g:ale_buffer_info[a:buffer].count

FUNCTION  <SNR>133_get_seperator()
Called 24 times
Total time:   0.019842
 Self time:   0.000293

count  total (s)   self (s)
   24   0.006456   0.000123   if airline#builder#should_change_group(a:prev_group, a:group)
   24   0.013373   0.000157     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#extensions#ctrlp#apply()
Called 4 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    4              0.000031   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  <SNR>112_is_excluded_window()
Called 4 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
    4              0.000008   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   16              0.000019   for matchw in g:airline_exclude_filenames
   12              0.000077     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   12              0.000007   endfor
                            
    4              0.000086   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    4              0.000003   return 0

FUNCTION  <SNR>124_get_counts()
Called 102 times
Total time:   0.003249
 Self time:   0.001481

count  total (s)   self (s)
  102   0.001934   0.000618   let l:counts = neomake#statusline#LoclistCounts()
                            
  102              0.000215   if empty(l:counts)
  102   0.000927   0.000475     return neomake#statusline#QflistCounts()
                              else
                                return l:counts
                              endif

FUNCTION  SyntasticStatuslineFlag()
Called 102 times
Total time:   0.019197
 Self time:   0.002140

count  total (s)   self (s)
  102   0.019141   0.002084     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  airline#extensions#syntastic#get_warning()
Called 51 times
Total time:   0.012654
 Self time:   0.000379

count  total (s)   self (s)
   51   0.012623   0.000348   return airline#extensions#syntastic#get('warning')

FUNCTION  airline#highlighter#reset_hlcache()
Called 2 times
Total time:   0.000693
 Self time:   0.000693

count  total (s)   self (s)
    2              0.000690   let s:hl_groups = {}

FUNCTION  airline#util#prepend()
Called 204 times
Total time:   0.001702
 Self time:   0.001702

count  total (s)   self (s)
  204              0.000583   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
  204              0.000675   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>41_airline_refresh()
Called 2 times
Total time:   0.172851
 Self time:   0.000309

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    2              0.000161   let fast=!empty(get(a:000, 0, 0))
    2              0.000014   if !exists("#airline")
                                " disabled
                                return
                              endif
    2   0.000387   0.000030   call airline#util#doautocmd('AirlineBeforeRefresh')
    2   0.000726   0.000033   call airline#highlighter#reset_hlcache()
    2              0.000009   if !fast
    2   0.156696   0.000025     call airline#load_theme()
    2              0.000001   endif
    2   0.014820   0.000009   call airline#update_statusline()
    2   0.000017   0.000007   call airline#update_tabline()

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 9 times
Total time:   0.000905
 Self time:   0.000604

count  total (s)   self (s)
    9              0.000031     let l:buffer = bufnr('')
                            
    9              0.000020     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    9              0.000036     if mode(1) isnot# 'n'
                                    return
                                endif
                            
    9   0.000170   0.000078     call s:StopCursorTimer()
                            
    9              0.000063     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    9              0.000033     if l:pos != s:last_pos
    9   0.000289   0.000079         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    9              0.000029         let s:last_pos = l:pos
    9              0.000074         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    9              0.000006     endif

FUNCTION  <SNR>118_hl_group_exists()
Called 277 times
Total time:   0.006177
 Self time:   0.006177

count  total (s)   self (s)
  277              0.001958   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  277              0.000238   return 1

FUNCTION  airline#extensions#ale#get_warning()
Called 51 times
Total time:   0.009028
 Self time:   0.000499

count  total (s)   self (s)
   51   0.008995   0.000467   return airline#extensions#ale#get('warning')

FUNCTION  airline#builder#new()
Called 4 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    4              0.000022   let builder = copy(s:prototype)
    4              0.000007   let builder._context = a:context
    4              0.000006   let builder._sections = []
                            
    4              0.000045   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    4              0.000004   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.172851   0.000309  <SNR>41_airline_refresh()
    2   0.156671   0.000194  airline#load_theme()
    5   0.131735   0.019473  airline#highlighter#highlight()
    2   0.116567   0.000214  airline#highlighter#load_theme()
  300   0.105589   0.028198  airline#highlighter#exec()
  554   0.089083   0.039215  airline#highlighter#get_highlight()
  103   0.065519   0.004377  <SNR>118_exec_separator()
 1108   0.042562             <SNR>118_get_syn()
    4   0.033905   0.000238  airline#update_statusline()
    4   0.033547   0.000209  <SNR>114_invoke_funcrefs()
  206   0.032117   0.002112  airline#themes#get_highlight()
    4   0.027833   0.003224  389()
    6   0.024256   0.000415  airline#util#exec_funcrefs()
   51   0.024108   0.008282  airline#check_mode()
  102   0.022867   0.003670  airline#extensions#syntastic#get()
   24   0.019842   0.000293  <SNR>133_get_seperator()
  102   0.019197   0.002140  SyntasticStatuslineFlag()
    2   0.018871   0.000030  airline#extensions#load_theme()
  300   0.015787             <SNR>118_CheckDefined()
  102   0.015540   0.008219  airline#extensions#ale#get()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 1108              0.042562  <SNR>118_get_syn()
  554   0.089083   0.039215  airline#highlighter#get_highlight()
  300   0.105589   0.028198  airline#highlighter#exec()
    5   0.131735   0.019473  airline#highlighter#highlight()
  300              0.015787  <SNR>118_CheckDefined()
    3              0.008683  airline#extensions#tabline#tabs#map_keys()
  102              0.008301  54()
   51   0.024108   0.008282  airline#check_mode()
  102   0.015540   0.008219  airline#extensions#ale#get()
   51   0.009536   0.007630  airline#extensions#whitespace#check()
  554              0.007306  <SNR>118_get_array()
  277              0.006177  <SNR>118_hl_group_exists()
  102              0.005099  44()
  357              0.004523  airline#util#append()
  103   0.065519   0.004377  <SNR>118_exec_separator()
  102   0.022867   0.003670  airline#extensions#syntastic#get()
  561              0.003497  airline#util#wrap()
    4   0.027833   0.003224  389()
  102   0.008756   0.002923  45()
  102   0.003730   0.002476  airline#util#shorten()

